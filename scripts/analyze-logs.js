#!/usr/bin/env node

/**
 * Log Analysis Utility
 * 
 * Provides tools to analyze request logs generated by the RequestLogger middleware
 * 
 * Usage:
 *   node scripts/analyze-logs.js [options]
 *   
 * Options:
 *   --date YYYY-MM-DD    Analyze logs for specific date (default: today)
 *   --errors             Show only error requests (4xx, 5xx)
 *   --slow               Show slow requests (>1000ms)
 *   --user USERNAME      Filter by username
 *   --endpoint PATH      Filter by endpoint path
 *   --stats              Show summary statistics
 *   --tail N             Show last N requests (default: 50)
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

class LogAnalyzer {
  constructor(logDirectory = './logs') {
    this.logDirectory = path.resolve(logDirectory)
  }

  /**
   * Get log file path for a specific date
   */
  getLogFilePath(date, type = 'requests') {
    const dateStr = date.toISOString().split('T')[0]
    return path.join(this.logDirectory, `${type}-${dateStr}.log`)
  }

  /**
   * Read and parse log entries for a specific date
   */
  async readLogEntries(date) {
    const logFile = this.getLogFilePath(date)
    
    if (!fs.existsSync(logFile)) {
      console.log(`No log file found for ${date.toISOString().split('T')[0]}`)
      return []
    }

    try {
      const content = fs.readFileSync(logFile, 'utf8')
      const lines = content.trim().split('\n').filter(line => line.trim())
      
      return lines.map((line, index) => {
        try {
          return JSON.parse(line)
        } catch (error) {
          console.warn(`Error parsing log line ${index + 1}: ${error.message}`)
          return null
        }
      }).filter(entry => entry !== null)
      
    } catch (error) {
      console.error(`Error reading log file: ${error.message}`)
      return []
    }
  }

  /**
   * Filter log entries based on criteria
   */
  filterEntries(entries, options = {}) {
    let filtered = entries

    if (options.errors) {
      filtered = filtered.filter(entry => entry.statusCode >= 400)
    }

    if (options.slow) {
      const threshold = options.slowThreshold || 1000
      filtered = filtered.filter(entry => entry.responseTime >= threshold)
    }

    if (options.user) {
      filtered = filtered.filter(entry => 
        entry.username?.toLowerCase().includes(options.user.toLowerCase())
      )
    }

    if (options.endpoint) {
      filtered = filtered.filter(entry => 
        entry.path?.includes(options.endpoint)
      )
    }

    if (options.method) {
      filtered = filtered.filter(entry => 
        entry.method?.toUpperCase() === options.method.toUpperCase()
      )
    }

    return filtered
  }

  /**
   * Generate summary statistics
   */
  generateStats(entries) {
    const stats = {
      totalRequests: entries.length,
      uniqueUsers: new Set(entries.map(e => e.username).filter(Boolean)).size,
      uniqueIPs: new Set(entries.map(e => e.ip).filter(Boolean)).size,
      avgResponseTime: 0,
      statusCodeBreakdown: {},
      methodBreakdown: {},
      endpointBreakdown: {},
      errorRate: 0,
      slowRequests: 0,
      timeRange: {
        start: null,
        end: null
      }
    }

    if (entries.length === 0) {
      return stats
    }

    // Calculate averages and breakdowns
    let totalResponseTime = 0
    let errorCount = 0
    let slowCount = 0

    const timestamps = entries.map(e => new Date(e.timestamp)).sort()
    stats.timeRange.start = timestamps[0]
    stats.timeRange.end = timestamps[timestamps.length - 1]

    entries.forEach(entry => {
      // Response time
      if (entry.responseTime) {
        totalResponseTime += entry.responseTime
        if (entry.responseTime >= 1000) {
          slowCount++
        }
      }

      // Status codes
      const statusCode = entry.statusCode || 'unknown'
      stats.statusCodeBreakdown[statusCode] = (stats.statusCodeBreakdown[statusCode] || 0) + 1
      
      if (statusCode >= 400) {
        errorCount++
      }

      // Methods
      const method = entry.method || 'unknown'
      stats.methodBreakdown[method] = (stats.methodBreakdown[method] || 0) + 1

      // Endpoints
      const endpoint = entry.path || 'unknown'
      stats.endpointBreakdown[endpoint] = (stats.endpointBreakdown[endpoint] || 0) + 1
    })

    stats.avgResponseTime = Math.round(totalResponseTime / entries.length)
    stats.errorRate = Math.round((errorCount / entries.length) * 100 * 100) / 100 // 2 decimal places
    stats.slowRequests = slowCount

    return stats
  }

  /**
   * Display entries in a formatted table
   */
  displayEntries(entries, options = {}) {
    const limit = options.tail || entries.length
    const displayEntries = entries.slice(-limit)

    if (displayEntries.length === 0) {
      console.log('No entries found matching the criteria.')
      return
    }

    console.log(`\n📋 Showing ${displayEntries.length} request(s):\n`)

    displayEntries.forEach(entry => {
      const statusColor = this.getStatusColor(entry.statusCode)
      const methodColor = this.getMethodColor(entry.method)
      const timeStr = new Date(entry.timestamp).toLocaleTimeString()
      
      console.log(
        `${timeStr} ${statusColor}${entry.statusCode}\x1b[0m ${methodColor}${entry.method}\x1b[0m ` +
        `${entry.path} - ${entry.responseTime || '?'}ms - ${entry.ip} ` +
        `${entry.username ? `[${entry.username}]` : '[anonymous]'}`
      )

      if (options.verbose && (entry.statusCode >= 400 || entry.responseTime >= 1000)) {
        console.log(`  Request ID: ${entry.requestId}`)
        if (entry.query && Object.keys(entry.query).length > 0) {
          console.log(`  Query: ${JSON.stringify(entry.query)}`)
        }
        if (entry.userAgent) {
          console.log(`  User-Agent: ${entry.userAgent.substring(0, 80)}...`)
        }
      }
    })
  }

  /**
   * Display statistics
   */
  displayStats(stats) {
    console.log('\n📊 Request Statistics:\n')
    
    console.log(`Total Requests: ${stats.totalRequests}`)
    console.log(`Unique Users: ${stats.uniqueUsers}`)
    console.log(`Unique IPs: ${stats.uniqueIPs}`)
    console.log(`Average Response Time: ${stats.avgResponseTime}ms`)
    console.log(`Error Rate: ${stats.errorRate}%`)
    console.log(`Slow Requests (>1s): ${stats.slowRequests}`)
    
    if (stats.timeRange.start && stats.timeRange.end) {
      console.log(`Time Range: ${stats.timeRange.start.toLocaleString()} - ${stats.timeRange.end.toLocaleString()}`)
    }

    console.log('\n📈 Status Code Breakdown:')
    Object.entries(stats.statusCodeBreakdown)
      .sort(([a], [b]) => parseInt(a) - parseInt(b))
      .forEach(([code, count]) => {
        const percentage = Math.round((count / stats.totalRequests) * 100)
        console.log(`  ${code}: ${count} (${percentage}%)`)
      })

    console.log('\n🔄 Method Breakdown:')
    Object.entries(stats.methodBreakdown)
      .sort(([,a], [,b]) => b - a)
      .forEach(([method, count]) => {
        const percentage = Math.round((count / stats.totalRequests) * 100)
        console.log(`  ${method}: ${count} (${percentage}%)`)
      })

    console.log('\n🎯 Top Endpoints:')
    Object.entries(stats.endpointBreakdown)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .forEach(([endpoint, count]) => {
        const percentage = Math.round((count / stats.totalRequests) * 100)
        console.log(`  ${endpoint}: ${count} (${percentage}%)`)
      })
  }

  /**
   * Get color for status code
   */
  getStatusColor(statusCode) {
    if (statusCode >= 500) return '\x1b[31m' // Red
    if (statusCode >= 400) return '\x1b[33m' // Yellow
    if (statusCode >= 300) return '\x1b[36m' // Cyan
    return '\x1b[32m' // Green
  }

  /**
   * Get color for method
   */
  getMethodColor(method) {
    const colors = {
      GET: '\x1b[32m',    // Green
      POST: '\x1b[33m',   // Yellow
      PUT: '\x1b[34m',    // Blue
      DELETE: '\x1b[31m', // Red
      PATCH: '\x1b[35m'   // Magenta
    }
    return colors[method] || '\x1b[37m' // White
  }
}

// CLI Interface
function parseArgs() {
  const args = process.argv.slice(2)
  const options = {
    date: new Date(),
    stats: false,
    errors: false,
    slow: false,
    tail: 50,
    verbose: false
  }

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]
    
    switch (arg) {
      case '--date':
        options.date = new Date(args[++i])
        break
      case '--errors':
        options.errors = true
        break
      case '--slow':
        options.slow = true
        break
      case '--user':
        options.user = args[++i]
        break
      case '--endpoint':
        options.endpoint = args[++i]
        break
      case '--method':
        options.method = args[++i]
        break
      case '--stats':
        options.stats = true
        break
      case '--tail':
        options.tail = parseInt(args[++i])
        break
      case '--verbose':
        options.verbose = true
        break
      case '--help':
        console.log(`
Log Analysis Utility

Usage: node scripts/analyze-logs.js [options]

Options:
  --date YYYY-MM-DD    Analyze logs for specific date (default: today)
  --errors             Show only error requests (4xx, 5xx)
  --slow               Show slow requests (>1000ms)
  --user USERNAME      Filter by username
  --endpoint PATH      Filter by endpoint path
  --method METHOD      Filter by HTTP method
  --stats              Show summary statistics
  --tail N             Show last N requests (default: 50)
  --verbose            Show additional details for errors/slow requests
  --help               Show this help message

Examples:
  node scripts/analyze-logs.js --stats
  node scripts/analyze-logs.js --errors --verbose
  node scripts/analyze-logs.js --user admin --tail 10
  node scripts/analyze-logs.js --date 2023-12-01 --endpoint /api/projects
        `)
        process.exit(0)
    }
  }

  return options
}

async function main() {
  const options = parseArgs()
  const analyzer = new LogAnalyzer()

  console.log(`🔍 Analyzing logs for ${options.date.toISOString().split('T')[0]}`)

  try {
    const entries = await analyzer.readLogEntries(options.date)
    const filtered = analyzer.filterEntries(entries, options)

    if (options.stats) {
      const stats = analyzer.generateStats(filtered)
      analyzer.displayStats(stats)
    } else {
      analyzer.displayEntries(filtered, options)
    }

  } catch (error) {
    console.error(`Error analyzing logs: ${error.message}`)
    process.exit(1)
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main()
}

export { LogAnalyzer }
